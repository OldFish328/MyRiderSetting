<application>
  <component name="Translation.Cache">
    <option name="lastTrimTime" value="1683178382667" />
  </component>
  <component name="Translation.States">
    <histories>
      <item value="Include archetypes that contain at least one (but possibly more) of the component types in the Any list." />
      <item value="Exclude archetypes that contain any of the component types in the None list." />
      <item value="The maximum acceleration of an agent as it follows a path, given in units" />
      <item value="Static counterpart of PurgeCache" />
      <item value="Purge" />
      <item value="This accumulates the `positions` (separations) and `headings` (alignments) of all the boids in each cell to: 1) count the number of boids in each cell 2) find the nearest obstacle and target to each boid cell 3) track which array entry contains the accumulated values for each boid's cell In this context, the cell represents the hashed bucket of boids that are near one another within cellRadius floored to the nearest int3. Note: `IJobNativeMultiHashMapMergedSharedKeyIndices` is a custom job to iterate safelyefficiently over the NativeContainer used in this sample (`NativeMultiHashMap`). Currently these kinds of changes or additions of custom jobs generally require access to datafields that aren't available through the `public` API of the containers. This is why the custom job type `IJobNativeMultiHashMapMergedSharedKeyIndicies` is declared in the DOTS package (which can see the `internal` container fields) and not in the Boids sample." />
      <item value="he relative vertical displacement of the owning GameObject." />
      <item value="The desired velocity of the agent including any potential contribution from avoidance" />
      <item value="Get the current steering target along the path" />
      <item value="Obstacle" />
      <item value="Returns the primary entity associated with the given object. This entity is from the destination world." />
      <item value="Entity indexes are recycled when an entity is destroyed. When an entity is destroyed, the EntityManager increments the version identifier. To represent the same entity, both the Index and the Version fields of the Entity object must match. If the Index is the same, but the Version is different, then the entity has been recycled." />
      <item value="An entity that is deferred and will be fully realized when this EntityCommandBuffer is played back" />
      <item value="A unique index for each set of commands added to this EntityCommandBuffer across all parallel jobs writing commands to this buffer. The `entityInQueryIndex` argument provided by &lt;see cref=&quot;SystemBase.Entities&quot;&gt; is an appropriate value to use for this parameter. In an &lt;see cref=&quot;IJobEntityBatch&quot;&gt; pass the 'batchIndex' value from &lt;see cref=&quot;IJobEntityBatch.Execute(ArchetypeChunk, int)&quot;&gt;." />
      <item value="An instantiated entity will have the same components and component values as the prefab entity, minus the Prefab tag component. Behavior at Playback: This command will throw an error if the source entity was destroyed before playback." />
      <item value="An instantiated entity will have the same components and component values as the prefab entity, minus the Prefab tag component. Behavior at Playback: This command will throw an error if the source entity was destroyed before playback.&lt;remarks&gt;" />
      <item value="An instantiated entity will have the same components and component values as the prefab entity, minus the Prefab tag component." />
      <item value="playback" />
      <item value="A unique index for each set of commands added to this EntityCommandBuffer across all parallel jobs writing commands to this buffer. The `entityInQueryIndex` argument provided by &lt;see cref=&quot;SystemBase.Entities&quot;&gt; is an appropriate value to use for this parameter. In an &lt;see cref=&quot;IJobEntityBatch&quot;&gt; pass the 'batchIndex' value from &lt;see cref=&quot;IJobEntityBatch.Execute(ArchetypeChunk, int)&quot;&gt;.&lt;param&gt;" />
      <item value="Behavior at Playback: If the entity already has this type of component, the value will just be set. Will throw an error if this entity is destroyed before playback, if this entity is still deferred, if T is type Entity, or adding this componentType makes the archetype too large." />
      <item value="Records a command to add component of type T to an entity." />
      <item value="&lt;summary&gt; Records a command to add component of type T to an entity. &lt;summary&gt; &lt;remarks&gt;Behavior at Playback: If the entity already has this type of component, the value will just be set. Will throw an error if this entity is destroyed before playback, if this entity is still deferred, if T is type Entity, or adding this componentType makes the archetype too large.&lt;remarks&gt; &lt;param name=&quot;sortKey&quot;&gt;A unique index for each set of commands added to this EntityCommandBuffer across all parallel jobs writing commands to this buffer. The `entityInQueryIndex` argument provided by &lt;see cref=&quot;SystemBase.Entities&quot;&gt; is an appropriate value to use for this parameter. In an &lt;see cref=&quot;IJobEntityBatch&quot;&gt; pass the 'batchIndex' value from &lt;see cref=&quot;IJobEntityBatch.Execute(ArchetypeChunk, int)&quot;&gt;.&lt;param&gt; &lt;param name=&quot;e&quot;&gt; The entity to have the component added. &lt;param&gt; &lt;param name=&quot;component&quot;&gt;The value to add on the new component in playback for the entity.&lt;param&gt; &lt;typeparam name=&quot;T&quot;&gt; The type of component to add. &lt;typeparam&gt; &lt;exception cref=&quot;NullReferenceException&quot;&gt;Throws if an Allocator was not passed in when the EntityCommandBuffer was created.&lt;exception&gt;" />
      <item value="If you write to a command buffer from a parallel Job, such as &lt;see cref=&quot;IJobForEach{T0}&quot;&gt; or &lt;see cref=&quot;IJobChunk&quot;&gt;, you must use the concurrent version of the command buffer, provided by" />
      <item value="This buffer system executes its list of command buffers during its &lt;see cref=&quot;OnUpdate&quot;&gt; function in the order you created the command buffers." />
      <item value="Creates an &lt;seealso cref=&quot;EntityCommandBuffer&quot;&gt; and adds it to this system's list of command buffers." />
      <item value="Records a command to create an entity with specified entity prefab" />
      <item value="[WriteGroup] Can exclude components which are unknown at the time of creating the query that have been declared to write to the same component." />
      <item value="[WriteGroup] Can exclude components which are unknown at the time of creating the query that have been declared to write to the same component. This allows for extending systems of components safely without editing the previously existing systems. The goal is to have a way for systems that expect to transform data from one set of components (inputs) to another (output[s]) be able to declare that explicit transform, and they exclusively know about one set of inputs. If there are other inputs that want to write to the same output, the query shouldn't match because it's a nonsensicalunhandled setup. It's both a way to guard against nonsensical components (having two systems write to the same output value), and a way to &quot;turn off&quot; existing systemsqueries by putting a component with the same write lock on an entity, letting another system handle it." />
      <item value="For simple systems that only run a single job and don't need to access the JobHandle themselves, it can be omitted from the Entities.ForEach() call. The job will implicitly use the system's Dependency handle as its input dependency, and update the system's Dependency property to contain the scheduled job's handle." />
      <item value="Referenced prefabs have to be declared so that the conversion system knows about them ahead of time" />
      <item value="A unique index for each set of commands added to this EntityCommandBuffer across all parallel jobs writing commands to this buffer. The `entityInQueryIndex` argument provided by" />
      <item value="this overload exists here with the sole purpose of being able to give the user a not-totally-horrible experience when they try to use an unsupported lambda signature. When this happens, the C compiler will go through its overload resolution, take the first candidate, and explain the user why the users lambda is incompatible with that first candidates' parametertype. We put this method here, instead of with the other .ForEach overloads, to make sure this is the overload that the c compiler will pick when generating its compiler error. If we didn't do that, it might pick a completely unrelated .ForEach extention method, like the one for IJobChunk. The only communication channel we have to the user to guide them to figuring out what their problem is is the name of the expected delegate type, as the c compiler will put that in its compiler error message. so we take this very unconventional approach here of encoding a message for the user in that type name, that is easily googlable, so they will end up at a documentation page that describes why some lambda signatures are compatible, and why some aren't, and what to do about that. the reason the delegate type is in the global namespace, is that it makes for a cleaner error message it's marked with an attribute to prevent it from showing up in intellisense." />
      <item value="Start of query creating functions for ForEachLambdaJobDescription. Unfortunately there's no C way to use generics to make these work for multiple jobdescription types, so we're lowteching it with t4 here." />
      <item value="A thread-safe command buffer that can buffer commands that affect entities and components for later playback." />
      <item value="If you want to create more than one entity from the data in this class" />
      <item value="It's also OK to not add any at all" />
      <item value="The indent level of the field labels" />
      <item value="Trying to destroy object that is already released to pool" />
      <item value="Shadowmap sampling matrix, from world space into shadowmap space" />
      <item value="Clear to black" />
      <item value="where something was rendered (via inverted depth test)" />
      <item value="Draw a quad, with shader that will produce white color everywhere" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="42" />
        <entry key="ENGLISH" value="43" />
      </map>
    </option>
  </component>
</application>